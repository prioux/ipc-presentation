<!DOCTYPE html>
<html>

<head>
  <title>Interprocess Communications</title>
  <link rel="stylesheet" href="css/reveal.css">
  <link rel="stylesheet" href="css/night.css">
  <link rel="stylesheet" href="plugin/highlight/style/monokai-sublime.css">
  <meta charset="utf-8"/>
</head>

<body>
  <div class="reveal">
    <div class="slides">

<!-- ############################## -->
<!-- ############################## -->
<!-- ############################## -->

<section id="top">

<section id="title">
  <h1>Interprocess Communication</h1>
  <h3>Pierre Rioux</h3>
  <h5>ACE lab Developer Meeting<br>June 2016</h5>
</section>

<!-- ****************************** -->

<section id="content">
  <h2>Table of content</h2>
  <ul>
    <li>Prologue: what are processes?</li>
    <li>IPC mechanisms:
      <ul>
        <li>signals</li>
        <li>environment variables</li>
        <li>files</li>
        <li>pipes</li>
        <li>fifos</li>
        <li>sockets</li>
      </ul>
    </li>
    <li>Epilogue: Quiz!</li>
  </ul>
</section>

</section>

<!-- ############################## -->
<!-- ############################## -->
<!-- ############################## -->

<section id="prologue">

<section id="aboutprocs">
  <h2>About processes</h2>
  <strong>The obvious stuff:</strong> a UNIX process is:
  <p>
  <ul>
    <li>an area of a computer's memory</li>
    <li>where the processor executes some instructions</li>
    <li>and manages some data</li>
  </ul>
</section>

<!-- ****************************** -->

<section id="procattr1">
  <h2>Processes attributes 1</h2>
  Processes have these attributes:
  <p>
  <ul>
    <li>a unique ID (called <em>pid</em>, 1 to 65535)</li>
    <li>a UNIX owner</li>
    <li>a UNIX group</li>
    <li>various time accounting</li>
  </ul>
  <p>
  These things <i>aren't that important</i> for this discussion.
</section>

<!-- ****************************** -->

<section id="procattr2">
  <h2>Processes attributes 2</h2>
  The operating system manages all the processes.
  <p>
  <ul>
    <li>processes are organized in a tree</li>
    <li>each process has a <em>parent process</em></li>
    <li>so each process also as a parent process ID (<em>ppid</em>)</li>
  </ul>
</section>

<!-- ****************************** -->

<section id="proctree">
  <h2>A tree of processes</h2>
  <img src="images/proctree.png">
</section>

<!-- ****************************** -->

<section id="attimportant">
  <h2>Some important attributes</h2>
  <i>All</i> processes have these three things
  which will be important:
  <p>
  <ul>
    <li><span style="color: #00f">environment variables</span></li>
    <li><span style="color: #f00">signal handlers</span></li>
    <li><span style="color: #0f0">file descriptors</span></li>
  </ul>
  <p>
  These are the essential components of IPC.
  <p>
  <img src="images/attimportant.png">
</section>

<!-- ****************************** -->

<section id="proccreate">
  <h2>How processes are created</h2>

  Surprisingly, the operating system has <strong>no</strong> mechanism
  for creating new processes from scratch.
  <p class="fragment">
  A process can only be created by another process...
  <p class="fragment">
  ... by making a <em>perfect copy</em> of itself.
  <p class="fragment">
  This is also how the tree structure emerges. The copy
  becomes a <em>child</em> of the original process.
  </p>
</section>

<!-- ****************************** -->

<section id="procdestroy">
  <h2>How processes are destroyed</h2>
   <ul>
     <li>They can simply finish their job</li>
     <li>They can be <em>terminated</em> by the operating system or by other processes</li>
     <li>And then the tree structure gets adjusted (no details here)</li>
   </ul>
</section>

</section>

<!-- ############################## -->
<!-- ############################## -->
<!-- ############################## -->

<section id="whatabout">

<section id="about1">
  <h2>What IPC is about</h2>
  This presentation is about the general concept of how <em>two processes</em> can
  send <i>information</i> to each other.
  <p>
  <img src="images/whatabout.png">
</section>

<!-- ****************************** -->

<section id="proccontext">
  <h2>Two IPC situations...</h2>
  <p class="fragment">
    Two processes on the <em>same</em> computer
    <img src="images/proccontext1.png">
  <p class="fragment">
    Two processes on the <em>different</em> computers
    <img src="images/proccontext2.png">
  </p>
</section>

</section>

<!-- ############################## -->
<!-- ############################## -->
<!-- ############################## -->

<section id="separate">

<section id="sep1">
  <h2>One at a time!</h2>
  Wait! What if the two processes run separately:
  <ul>
    <li>one after the other...</li>
    <li>never at the same time...</li>
  </ul>
  <br>
  <img src="images/sep2.png">
  ... there is only <em>one</em> way they can
  send information to each other.<br>
  Can you guess how?
  <p class="fragment">
  By creating files.
  </p>
</section>

</section>

<!-- ############################## -->
<!-- ############################## -->
<!-- ############################## -->

<section id="signals">

<section id="sig1">
  <h2>Signals</h2>
  Processes can send and receive <em>signals</em>.
  <p>
  They are a sort of ultra-simple message.
  <p>
  The only content is the type of signal, a simple number.
  <p>
  <ul>
    <li>the types are encoded as a number from 1 to N</li>
    <li>MacOS X (BSD-like) has about 30 signals</li>
    <li>Linux has about 60 signals</li>
    <li>they act like very quick <em>pings</em>
    <li>for convenience, short names are given to each type</li>
  </ul>
  <p>
  E.g: Signal #<em>11</em> is called <strong>SIGSEGV</strong>.
</section>

<!-- ****************************** -->

<section id="siglist">
  <h2>List of signals</h2>
  You can get a full list of signals using the <em>kill -l</em> command:
  <p>

<pre>
<em>macosx%</em> kill -l
 1) SIGHUP       2) SIGINT       3) SIGQUIT      4) SIGILL
 5) SIGTRAP      6) SIGABRT      7) SIGEMT       8) SIGFPE
 9) SIGKILL     10) SIGBUS      11) SIGSEGV     12) SIGSYS
13) SIGPIPE     14) SIGALRM     15) SIGTERM     16) SIGURG
17) SIGSTOP     18) SIGTSTP     19) SIGCONT     20) SIGCHLD
21) SIGTTIN     22) SIGTTOU     23) SIGIO       24) SIGXCPU
25) SIGXFSZ     26) SIGVTALRM   27) SIGPROF     28) SIGWINCH
29) SIGINFO     30) SIGUSR1     31) SIGUSR2
</pre>
</section>

<!-- ****************************** -->

<section id="sigmac">
  <h2>Signals On OS X</h2>

<pre>
<em>NAME</em>            <em>Default Action</em>          <em>Description</em>
SIGHUP          terminate process       terminal line hangup
SIGINT          terminate process       interrupt program
SIGQUIT         create core image       quit program
SIGILL          create core image       illegal instruction
SIGTRAP         create core image       trace trap
SIGABRT         create core image       abort(3) call (formerly SIGIOT)
SIGEMT          create core image       emulate instruction executed
SIGFPE          create core image       floating-point exception
SIGKILL         terminate process       kill program
SIGBUS          create core image       bus error
SIGSEGV         create core image       segmentation violation

<strong>... etc...</strong>
</pre>

   Ref: <em>sigvec(2)</em>
</section>

<!-- ****************************** -->

<section id="siglinux">
  <h2>Signals on Linux</h2>
<pre>
<em>Signal</em>     <em>Value</em>     <em>Action</em>   <em>Comment</em>
SIGHUP        1       Term    Hangup detected on controlling terminal
                              or death of controlling process
SIGINT        2       Term    Interrupt from keyboard
SIGQUIT       3       Core    Quit from keyboard
SIGILL        4       Core    Illegal Instruction
SIGABRT       6       Core    Abort signal from abort(3)
SIGFPE        8       Core    Floating point exception
SIGKILL       9       Term    Kill signal
SIGSEGV      11       Core    Invalid memory reference

<strong>... etc...</strong>
</pre>

   Ref: <em>signal(7)</em>
</section>

<!-- ****************************** -->

<section id="sigsend1">
  <h2>Sending signals 1</h2>
  Signals are sent from one process to another <i>on the same computer</i>.
  <p>
  To send a signal you need two values:
  <p>
  <ul>
    <li>the <em>number</em> for the type of signal, e.g. <strong>11</strong>
    <li>(though it's better to use constants, e.g. <strong>SIGSEGV</strong> instead)</li>
    <li>the process ID (<em>pid</em>) of the receiver</li>
    <li>most languages have a simple method or function that takes these two values
        and send the signal
    </li>
  </ul>
</section>

<!-- ****************************** -->

<section id="sigsend2">
  <h2>Sending signals 2</h2>
  These examples will all send the signal #<em>15</em>, <strong>SIGTERM</strong><br>
  to a process with pid <em>1234</em> :
  <p>
  <ul>
    <li>Bash: <pre>kill -TERM 1234 # same as kill -15 1234</pre></li>
    <li>Perl: <pre>kill(SIGTERM,1234); # SIGTERM is a constant   </pre></li>
    <li>PHP: <pre>posix_kill(1234, SIGTERM);</pre></li>
    <li>Ruby: <pre>Process.kill("TERM", 1234)</pre></li>
  </ul>
</section>

<!-- ****************************** -->

<section id="sigrec1">
  <h2>Receiving signals 1</h2>
  A process can set up <em>handlers</em> to run a<br>
  piece of code when a signal is received.
  <p>
  <ul>
    <li>not all signals can be handled (e.g. #<em>9</em> a.k.a. <strong>SIGKILL</strong>)</li>
    <li>the handler is run asynchronously from the code of the process</li>
    <li>handlers are not re-entrant</li>
    <li>only one signal at a time can be handled</li>
    <li>there is a default behavior for most signals</li>
    <li>you <i>can't tell</i> what other process has sent the signal!
  </ul>
</section>

<!-- ****************************** -->

<section id="sigrec2">
  <h2>Receiving signals 2</h2>
  In all languages, this consists in setting up a method or<br>
  subroutine to handle a signal, and then telling the OS to<br>
  invoke that method when the signal is received.
  <p>
  <div class="cell">
  <ul>
    <li>Bash:
<pre>
function oh_no { echo Hello }   
trap oh_no SIGUSR1
</pre>
    </li>
    <li>Perl:
<pre>
sub oh_no {
  print "Hello\n"
}
$SIG{'USR1'} = \&oh_no;
</pre>
    </li>
  </ul>
  </div>

  <div class="cell">
  <ul>
    <li>PHP:
<pre>
function oh_no($s) { echo "Hello" }   
pcntl_signal(SIGUSR1, "oh_no");
</pre>
    </li>
    <li>Ruby:
<pre>
Signal.trap("USR1") do
  puts "Hello"
end
&nbsp;
</pre>
    </li>
  </ul>
  </div>
</section>

<!-- ****************************** -->

<section id="sigcommon">
  <h2>Common signals</h2>
  <table>
    <tr>
      <th>Signal name</th>
      <th>Default effect</th>
      <th>Trappable?</th>
      <th>Use it for</th>
    </tr>
    <tr>
      <td>INT&nbsp;(2)</td>
      <td>terminates process</td>
      <td>Yes</td>
      <td>User wants out?</td>
    </tr>
    <tr>
      <td>TERM&nbsp;(15)</td>
      <td>terminates process</td>
      <td>Yes</td>
      <td>Clean up properly</td>
    </tr>
    <tr>
      <td>KILL&nbsp;(9)</td>
      <td>terminates process</td>
      <td>Nope!</td>
      <td>Can't do anything about it</td>
    </tr>
    <tr>
      <td>USR1,&nbsp;USR2</td>
      <td>No effect</td>
      <td>Yes!</td>
      <td>Anything you want</td>
    </tr>
  </table>
</section>

<!-- ****************************** -->

<section id="sigreca1">
  <h2>Example A, 1</h2>
  Script <em>test_inc.rb</em>
<pre class="transp"><code class="ruby" data-trim>
#!/usr/bin/ruby

float   = 0.0
counter = 0

while true do
  float = float.next_float
  counter += 1
  puts "Float=" + float.to_s if counter % 1000000 == 0
end
</code></pre>
<p>
We get about two reports per second on my Mac mini:
<pre>
<em>unix%</em> ruby test_inc.rb
Float=4.940656e-318
Float=9.881313e-318
Float=1.482197e-317
Float=1.9762626e-317
Float=2.470328e-317
Float=2.964394e-317
...
</pre>
</section>

<!-- ****************************** -->

<section id="sigreca2">
  <h2>Example A, 2</h2>
  Improved script <em>test_inc.rb</em>
<pre class="transp"><code class="ruby" data-trim>
#!/usr/bin/ruby

float = 0.0
Signal.trap("USR1") { puts "Float=" + float.to_s }

while true do
  float = float.next_float
end
</code></pre>
  In two terminals:
  <div class="cell">
<pre>
<em>unix%</em> ruby test_inc.rb                 
Float=1.158144256e-315                          
Float=1.826497665e-315                          
Float=1.014102923e-314                          
</pre>
  </div>
  <div class="cell">
<pre>
<em>unix%</em> kill -USR1 3272                        
<em>unix%</em> kill -USR1 3272                        
<em>unix%</em> kill -USR1 3272                        
</pre>
  </div>
</section>

<!-- ****************************** -->

<section id="sigrecb1">
  <h2>Example B, 1</h2>
  In <strong>CBRAIN</strong> we have a maintenance process that regularly
  archives some tasks' work directories. The main Ruby loop looks like this:
  <p>
<pre class="transp"><code data-trim class="ruby">
# Ruby from CBRAIN (simplified)
task_list.each do |task|   # iterates over each task, likely hundreds
  task.archive_work_dir()  # this can take several minutes
done
</code></pre>
  <p>
  Sometimes, maintenance (or shutdowns) need to be<br>
  performed while this process has already started.
  <p>
  If we kill this process at an arbitrary time, we will likely end up with:
  <ul>
    <li>work directories only partly archived</li>
    <li>the database state inconsistent</li>
    <li>probably leftover temporary files</li>
  </ul>
</section>

<!-- ****************************** -->

<section id="sigrecb2">
  <h2>Example B, 2</h2>
   What we do instead is allow the admin to tell<br>
   the process to finish up whatever task is currently<br>
   being archived, then stop before doing the next.
   <p>
<pre class="transp"><code data-trim class="ruby">
# Ruby from CBRAIN (simplified)

keep_going = true

Signal.trap("TERM")  { keep_going = false }

task_list.each do |task|   # iterates over each task, likely hundreds
  task.archive_work_dir()  # this can take several minutes
  break if ! keep_going    # break from the loop if signal received!
done
</code></pre>
<p>
This way we know that no task is left at an inconsistent state.
</section>

</section>

<!-- ############################## -->
<!-- ############################## -->
<!-- ############################## -->

<section id="env">

<section id="env1">
  <h2>Environment variables</h2>
  Each process maintains a set of environment variables.
  <p>
  <ul>
    <li>they are simple pairs of key=value</li>
    <li>all keys and values are strings</li>
    <li>by convention, keys are UPPERCASE (but not enforced)</li>
    <li>e.g. <em>USER=prioux</em></li>
    <li>a few have special meanings for the operating system (e.g. <em>PATH</em>)</li>
    <li>but most are arbitrary strings that programs agree on by convention or by specification</li>
  </ul>
</section>

<!-- ****************************** -->

<section id="envmis">
  <h2>Misunderstandings</h2>
  People think setting environment variables<br>
  affect magically all the programs they run. In fact:
  <p>
  <ul>
    <li>each process has <i>its own private set</i> of environment variables</li>
    <li>a process can set, change or delete its own variables</li>
    <li>but it is <em>not possible</em> for a process to change the environment variables of any <em>other</em> process</li>
  </ul>
  <p>
  <strong>Puzzle: so how can this be even used for IPC ?</strong>
</section>

<!-- ****************************** -->

<section id="envfork1">
  <h2>Environment variables<br>are inherited</h2>
  Processes are created by forking from other processes.
  <p>
  <ul>
    <li>a parent process #123 sets <em>ABC=def</em> in its environment</li>
    <li>when the process <em>fork()</em>, the child process #987 also has <em>ABC=def</em></li>
    <li><strong>all</strong> environment variables are <i>copied</i> exactly, in fact</li>
  </ul>
  <p>
  The end result is that a process has a capability to<br>
  transfer a set of <em>X=y</em> values to their child processes.
  <p>
  Obviously, this communication mechanism is <strong>unidirectional</strong>:
  the information flows only from parents to their children.
  <p>
  Also, it can only be done once,<br>
  just before the child process is created.
</section>

<!-- ****************************** -->

<section id="envfork2">
  <h2>fork() often leads to exec()</h2>
  If processes create children that are identical,<br>
  how can there be processes of different types?
  <p>
  <ul>
    <li>yes, after <em>fork()</em>, the child process is <em>identical</em></li>
    <li>but often, the child process elects to change its executable code
        by invoking <em>exec()</em></li>
    <li>this replaces the code, but <em>keeps the environment variables intact</em></li>
  </ul>
  <img src="images/envfork2.png">
</section>

<!-- ****************************** -->

<section id="envbash">
  <h2>From the shell<br> (bash, sh, tcsh etc)</h2>
  Interactively, the most common situation is:
  <p>
  <ul>
    <li>set environment variables of a <em>shell</em> process</li>
    <li>the shell itself likely doesn't care about those variables</li>
    <li>but other processes launched will inherit them and use them</li>
  </ul>
  <p>
<pre>
<em>unix%</em> export VISUAL=/bin/vim  # how bash sets its own environment variables
<em>unix%</em> git commit              # will launch <em>vim</em> to edit commit message
<em>unix%</em> export VISUAL=/bin/nano
<em>unix%</em> git commit              # now will launch <em>nano</em> to edit commit message
</pre>
</section>

<!-- ****************************** -->

<section id="envenv1">
  <h2>The <em>env</em> command 1</h2>
  One of the simplest example is the UNIX command called <em>env</em> .
  <p>
  When run with </strong>no arguments</strong>:
  <p>
  <ul>
    <li>it just prints all the environment variables<br>
        it has received from its parent</li>
  </ul>
  <p>
<pre>
<em>unix%</em> env
ABC=def
</pre>
  <p>
  This is a great way to inspect what are the<br>
  environment variables currently set in your shell.
</section>

<!-- ****************************** -->

<section id="envenv2">
  <h2>The <em>env</em> command 2</h2>
  When run with some ENV assignments in front<br>
  of another <strong>command</strong> in argument...
  <p>
<pre>
env A=b C=d E=f <strong>command</strong> arg1 arg2 arg3 ...
</pre>
  <p>
  <ul>
    <li>it will change its own environment (A=b, C=d, etc)</li>
    <li>then launch the <strong>command</strong> as a subprocess, which will inherit those variables</li>
    <li>the environment of the shell running <em>env</em> is, itself, of course not modified in any way</li>
  </ul>
  <p>
<pre>
<em>unix%</em> env
ABC=def
<em>unix%</em> env TMPDIR=/home/prioux/tmp <strong>minc_scramble</strong> abcde_t1.mnc.gz
minc scramble 1.0 : file abcde_t1.mnc.gz scrambled in /home/prioux/tmp/abcde_t1.mnc.gz
<em>unix%</em> env
ABC=def
<em>unix%</em> export TMPDIR=/home/prioux/tmp  # change this in SHELL level now
<em>unix%</em> env
ABC=def
TMPDIR=/home/prioux/tmp
</pre>
</section>

<!-- ****************************** -->

<section id="envsystem">
  <h2>System variables: examples</h2>
  (Very few) environment variables have system meanings; the values they
  have directly affect some system aspect of the process.
  <p>
  <table>
    <tr>
      <th>Name</th>
      <th>Role</th>
      <th>Example</th>
    </tr>
    <tr>
      <td>PATH</td>
      <td>dirs to search for executables (when running <em>exec()</em>)</td>
      <td><pre>/bin:/usr/bin:/sbin</pre></td>
    </tr>
    <tr>
      <td>LD_LIBRARY_PATH</td>
      <td>dirs to search for libraries</td>
      <td><pre>/lib:/usr/lib</pre></td>
    </tr>
  </table>
</section>

<!-- ****************************** -->

<section id="envuser">
  <h2>User or app variables: examples</h2>
  Most environment variables are specific to<br>
  some programs, or are defined by conventions.
  <p>
  <table>
    <tr>
      <th>Name</th>
      <th>Role</th>
      <th>Example</th>
    </tr>
    <tr>
      <td>VISUAL</td>
      <td>if set, what program to use to launch a visual text editor</td>
      <td><pre>/bin/vim</pre></td>
    </tr>
    <tr>
      <td>EDITOR</td>
      <td>if set, what program to use to launch a text editor</td>
      <td><pre>/bin/ed</pre></td>
    </tr>
    <tr>
      <td>PAGER</td>
      <td>if set, what program to use to launch a pager</td>
      <td><pre>/usr/bin/less</pre></td>
    </tr>
    <tr>
      <td>DISPLAY</td>
      <td>X-window client programs get the socket to the X-window server</td>
      <td><pre>/tmp/socks-5/xwin:0</pre></td>
    </tr>
    <tr>
      <td>LESS</td>
      <td>options for the pager <em>less</em></td>
      <td><pre>MeqisXRF</pre></td>
    </tr>
  </table>
</section>

<!-- ****************************** -->

<section id="envman">
  <h2>In the manual pages</h2>
  Most manual pages describe, at their end, the environment variables
  used by their programs.
  <p>
<pre>
<em>unix%</em> man less
LESS(1)                                               LESS(1)

NAME
       less - opposite of more

SYNOPSIS
       less -?
       less --help
       less -V

<strong>(skipped through using 'more')</strong>

ENVIRONMENT VARIABLES
       EDITOR The name of the editor (used for the v command).

       LANG   Language for determining the character set.

       LESS   Options which are passed to less automatically.

<strong>(skipped through using 'more')</strong>

<em>unix%</em> export PAGER=less    # from now on I page using 'less'
<em>unix%</em> export LESS=MeqisXRF # also, 'less' will default to these options
</pre>
</section>

<!-- ****************************** -->

<section id="envmt">
  <h2>Example with 'mt'</h2>
  <em>mt</em> is a UNIX command to manipulate <em>m</em>agnetic <em>t</em>apes.
  <p>
<pre>
<em>unix%</em> mt -f /dev/nst0 status
<em>unix%</em> mt -f /dev/nst0 rewind
<em>unix%</em> mt -f /dev/nst0 fsf 3
<em>unix%</em> man mt # can I make this simpler?
</pre>

<pre>
<em>unix%</em> export TAPE=/dev/nst0  # seems the mt commands knows how to use this
<em>unix%</em> mt status
<em>unix%</em> mt rewind
<em>unix%</em> mt fsf 3
</pre>
</section>

<!-- ****************************** -->

<section id="envsource">
  <h2>'source' statements</h2>
  Some text files, known as initialization scripts,<br>
  often set environments variables.
  <p>
  Some are application-specific:<br>e.g. the <em>init.sh</em> in the <i>MNI Quarantine</i>.
  <p>
  Some are used for user preferences or customizations:<br>e.g. <em>$HOME/.bashrc</em>
  <p>
  In all cases, the script must be <strong>sourced</strong>, not executed.
  <p>
<pre>
<em>unix%</em> cat init.sh
export ABC=def
<em>unix%</em> bash init.sh   # will not do anything: it's a distinct subprocess!
<em>unix%</em> echo $ABC
<em>unix%</em> source init.sh # affects current shell: it reads the lines itself
<em>unix%</em> echo $ABC
def
</pre>
</section>

</section>

<!-- ############################## -->
<!-- ############################## -->
<!-- ############################## -->

<section id="fd">

<!-- ****************************** -->

<section id="fd1">
  <h2>File descriptors</h2>
  Each process maintains a private list of file descriptors (<em>FDs</em>)
  <p>
  <ul>
    <li>it's an array, indexed at 0</li>
    <li>each entry corresponds to communication channel</li>
    <li>they may not all be in use</li>
    <li>they can be unidirectional or bidirectional</li>
  </ul>
  <p>
  <img src="images/fd1.png">
</section>

<!-- ****************************** -->

<section id="fd2">
  <h2>FDs for other things than files</h2>
  Typically they are connected to <em>files</em>...<br>
  but they can be many other things too:
  <p>
  <ul>
    <li><em>anonymous pipes</em> to other processes</li>
    <li><em>named pipes</em></li>
    <li><em>network sockets</em></li>
    <li><em>UNIX-domain sockets</em></li>
    <li>block devices (disks, tapes etc)</li>
    <li>character devices (keyboards, ttys, speakers etc)</li>
  </ul>
</section>

<!-- ****************************** -->

<section id="fd3">
  <h2>Processes can have lots of FDs</h2>
  Modern LINUX systems allocate a lot of FDs to each process.
  <p>
  <small>It used to be that a process could have a maximum of something like 64 FDs,
  nowadays it's more like 1024!</small>
  <br>
  <small>Below: file descriptors for process <em>mysqld</em> on <i>Ludmer</i> server (excerpt)</small>
  <br>
<pre data-trim>
COMMAND  FD   TYPE       DEVICE   SIZE/OFF NAME
mysqld    0r   CHR          1,3        0t0 /dev/null
mysqld    1w   REG          8,5      18042 /var/log/mysqld.log
mysqld    2w   REG          8,5      18042 /var/log/mysqld.log
mysqld    3uW  REG          8,5 1226833920 /var/lib/mysql/ibdata1
mysqld    4u   REG          8,4          0 /tmp/ibHSKNG9 (deleted)
mysqld    5u   REG          8,4        473 /tmp/ibP57ycj (deleted)
mysqld    6u   REG          8,4        103 /tmp/ibLQzkIs (deleted)
mysqld    7u   REG          8,4          0 /tmp/ibfRYmeC (deleted)
mysqld    8uW  REG          8,5    5242880 /var/lib/mysql/ib_logfile0
mysqld    9uW  REG          8,5    5242880 /var/lib/mysql/ib_logfile1
mysqld   10u  IPv4     55802736        0t0 *:mysql (LISTEN)
mysqld   11u   REG          8,4       1467 /tmp/ibROAYLL (deleted)
mysqld   12u  unix 0xfff882ed80        0t0 /var/lib/mysql/mysql.sock
mysqld   13u  IPv4     61704300        0t0 192.168.122.1:mysql->ccna:48212 (ESTABLISHED)
mysqld   15u   REG          8,5      30720 /var/lib/mysql/wp_ludmer/wp_options.MYI
mysqld   16u   REG          8,5     580904 /var/lib/mysql/wp_ludmer/wp_options.MYD
mysqld   37u   REG          8,5       4096 /var/lib/mysql/canadachina/MMSE.MYI
mysqld   38u   REG          8,5       1704 /var/lib/mysql/canadachina/MMSE.MYD
mysqld   <em>52</em>u   REG          8,5      25300 /var/lib/mysql/wp_nist/wp_usermeta.MYD
</pre>
</section>

<!-- ****************************** -->

<section id="fd4">
  <h2>FDs are reusable</h2>
  File descriptors go through a cycle of re-use:
  <p>
  <ol>
    <li>they are opened and connected to a resource</li>
    <li>data is sent and/or received</li>
    <li>they are closed</li>
    <li>they can be reopened to another resource</li>
    <li>etc</li>
  </ol>
</section>

<!-- ****************************** -->

<section id="fdnotfh">
  <h2>A common confusion</h2>
  File descriptors are lower level than <strong>file handles</strong>.
  <p>
  What we typically call a file handle (FH) is often the product of
  a library or language providing an API to the file descriptors.
  <p>
  The most common one is the C <em>stdio</em> library, which works on structures
  that hide the file descriptors.
  <p>
  <h4>Opening a file in C using file descriptors</h4>
<pre class="transp"><code class="c" data-trim>
int fd;
fd = open("/tmp/my_file",O_RDONLY);
</code></pre>
  <h4>Opening a file in C using the <em>stdio</em> file handles</h4>
<pre class="transp"><code class="c" data-trim>
File *fh;
fh = fopen("/tmp/my_file","r");
</code></pre>
</section>

<!-- ****************************** -->

<section id="fdstd">
  <h2>The three standard FDs</h2>
  A common convention for UNIX processes are three standard FDs
  <p>
  <ul>
    <li><i>Standard input</i> ('STDIN', file descriptor 0)<br>
      <small>a stream going into the process</small>
    </li>
    <li><i>Standard output</i> ('STDOUT' file descriptor 1)<br>
      <small>a stream going out of the process</small>
    </li>
    <li><i>Standard error</i> ('STDERR', file descriptor 2)<br>
      <small>a stream going out the process too</small>
    </li>
  </ul>
  <p>
  <img src="images/fdstd.png">
</section>

<!-- ****************************** -->

<section id="fdanon">
  <h2>Standard streams<br>connect to anything</h2>
  Processes <em>do not care</em> what theirs<br>
  standards streams are connected to.
  <p>
  They can be connected to files, the streams of other<br>
  processes, terminals, etc, just like any other FDs.
  <p>
  <div class="cell"><img src="images/fdanon1.png"></div>
  <div class="cell"><img src="images/fdanon2.png"></div>
</section>

<!-- ****************************** -->

<section id="fdblocks">
  <h2>Pipeline building blocks</h2>
  The standard channels allow building<br>
  pipelines by linking processes together
  <p>
  <img src="images/fdblocks.png">
</section>

<!-- ****************************** -->

<section id="fd_cat">
  <h2>Some useful building blocks</h2>
  UNIX commands are part of a <em>toolbox</em> of processes<br>
  that can be used to build such pipelines.
  <img src="images/fd_cat.png">
<pre>
# 'cat' command: copies <em>all</em> input to output
<em>unix%</em> cat
hello how are you?
<i>^D</i>
hello how are you?
</pre>
</section>

<!-- ****************************** -->

<section id="fd_echo">
  <img src="images/fd_echo.png">
<pre>
# 'echo' command: sends as string each argument, each separated by one space
<em>unix%</em> echo hi    how    "are  you" my,friend
hi how are  you my,friend
</pre>
</section>

<!-- ****************************** -->

<section id="fd_tee">
  <img src="images/fd_tee.png">
<pre>
# 'tee' command: copies <em>all</em> input to output, and a copy to a separate file
<em>unix%</em> tee myout
hi there
<i>^D</i>
hi there
<em>unix%</em> cat myout
hi there
</pre>
</section>

<!-- ****************************** -->

<section id="fd_head">
  <img src="images/fd_head.png">
<pre>
# 'head' command: copies <em>only the first N lines of</em> of input to output
<em>unix%</em> head -2
line 1
line 2
line 3
<i>^D</i>
line 1
line 2
</pre>
</section>

<!-- ****************************** -->

<section id="fd_tail">
  <img src="images/fd_tail.png">
<pre>
# 'tail' command: copies <em>only the last N lines of</em> of input to output
<em>unix%</em> tail -2
line 1
line 2
line 3
<i>^D</i>
line 2
line 3
</pre>
</section>

<!-- ****************************** -->

<section id="fd_grep">
  <img src="images/fd_grep.png">
<pre>
# 'grep' command: select <em>only the input lines matching a regex</em> and sends them to output
<em>unix%</em> grep pierre
natacha drinks coffee
but pierre eats chocolate
and tristan writes code
<i>^D</i>
but pierre eats chocolate
</pre>
</section>

<!-- ****************************** -->

<section id="fd_sort">
  <img src="images/fd_sort.png">
<pre>
# 'sort' command: reads all lines, sorts them, then sends them to output
<em>unix%</em> sort
natacha drinks coffee
but pierre eats chocolate
and tristan writes code
<i>^D</i>
and tristan writes code
but pierre eats chocolate
natacha drinks coffee
</pre>
</section>

<!-- ****************************** -->

<section id="fd_cut">
  <img src="images/fd_cut.png">
<pre>
# 'cut' command: select <em>part of lines</em> and sends them to output
<em>unix%</em> cut -d: -f2,4
pierre:rioux:le:fou
alanis:morissette:the:singer
justin:trudeau:le:politicien
<i>^D</i>
rioux:fou
morissette:singer
trudeau:politicien
</pre>
</section>

<!-- ****************************** -->

<section id="fd_uniq">
  <img src="images/fd_uniq.png">
<pre>
# 'uniq' command: removes successive <em>duplicate lines</em> and sends them to output
<em>unix%</em> uniq
hello
hello
goodbye
hello
<i>^D</i>
hello
goodbye
hello
</pre>
</section>

<!-- ****************************** -->

<section id="fd_gzip">
  <img src="images/fd_gzip.png">
<pre>
# 'gzip' command: compress input stream and sends the compressed result to output
<em>unix%</em> gzip
pierre eats chocolate
<i>^D</i>
$@<i>~</i>Fz-#@<strong>0</strong>
</pre>
</section>

<!-- ****************************** -->

<section id="fdstdin">
  <h2>Input stream: files or STDIN</h2>
  Some commands act differently depending on how they
  are invoked, when it comes to their <em>inputs</em>:
  <p>
  <ul>
    <li>With no arguments, they read from STDIN</li>
    <li>(all of the previous examples did that)</li>
    <li>With arguments, they read from each file in turn</li>
  <ul>
  <div class="cell">
  <img src="images/fd_cat.png">
<pre>
<em>unix%</em> cat
hello how are you?
<i>^D</i>
hello how are you?
</pre>
  </div>
  <div class="cell">
  <img src="images/fd_catF.png">
<pre>
<em>unix%</em> cat file
line 1 of 'file'
line 2 of 'file'
line 3 of 'file'
</pre>
  </div>
</section>

<!-- ****************************** -->

<section id="fdgrepcut">
  <h2>Grep &amp; Cut</h2>
  The <em>grep</em> and <em>cut</em> command, when used together to
  parse a data stream, might remind people of some relational DB primitives
  <p>

<pre>
# A sample (dummy) UNIX password file
prioux:x:1037:1037:Pierre Rioux:/home/prioux:/bin/bash
mero:x:1047:1047:Marc Rousseau:/home/mero:/bin/bash
sdas:x:1055:1055:Samir Das:/home/sdas:/bin/tcsh
nbeck:x:1055:1055:Natacha Beck:/home/sdas:/bin/sh
tglat:x:1055:1055:Tristan Glatard:/home/sdas:/bin/tcsh
</pre>

<small>Find all users of the <strong>tcsh</strong> shell</small>:
<pre>
<em>unix%</em> cat /etc/passwd | <em>grep</em> /bin/tcsh | <em>cut</em> -d: -f5
Samir Das
Tristan Glatard
</pre>

So, what do grep and cut correspond to?

<p class="fragment">
grep : the <strong>where</strong> clauses of a SQL select statement
<br>
cut : the <strong>select `columns`</strong> part.
</p>
</section>

<!-- ****************************** -->

<section id="fdredir1">
  <h2>Bash redirection</h2>
  The bash shell (and other shells too) have
  syntax to specify how to connect the standard channels
  to <em>files</em> before the command is run.
  <p>

  <div class="cell">
<pre>
<em>unix%</em> program 0&lt; file # fd 0 = stdin
<em>unix%</em> program  &lt; file
</pre>
    <img src="images/fd_redirin.png">
  </div>

  <div class="cell">
<pre>
<em>unix%</em> program 1&gt; file # fd 1 = stdout
<em>unix%</em> program  &gt; file
</pre>
    <img src="images/fd_redirout.png">
  </div>
</section>

<!-- ****************************** -->

<section id="fdredir2">

  <div class="cell">
<pre>
<em>unix%</em> program 2&gt; file # fd 2 = stderr
</pre>
    <img src="images/fd_redirerr.png">
  </div>

  <div class="cell">
<pre>
<em>unix%</em> program 0&lt; abc 1&gt; def 2&gt; xyz
</pre>
    <img src="images/fd_redirall.png">
  </div>
</section>

<!-- ****************************** -->

<section id="fdpipe">
  <h2>Bash piping</h2>
  The standard output of a process can be connected<br>
  to the standard input of another one.
  <p>
  <div class="cell">
<pre>
<em>unix%</em> wc -l memoirs.txt
7233
</pre>
    <img src="images/fd_wcmem.png">
  </div>

  <div class="cell">
<pre>
<em>unix%</em> cat memoirs.txt | wc -l
7233
</pre>
    <img src="images/fd_catwc.png">
  </div>
</section>

<!-- ****************************** -->

<section id="fderr">
  <h2>Standard error handling</h2>
  <ul>
    <li>often used for diagnostics or messages</li>
    <li>can be redirected or merged with standard output</li>
  </ul>
<pre>
<em>unix%</em> ls -l abc.txt def.txt
def.txt: no such file or directory
-rwxr-xr-x prioux wheel 12311 abc.txt
<em>unix%</em> ls -l abc.txt def.txt &gt; out 2&gt; err
<em>unix%</em> ls -l abc.txt def.txt | wc -l
def.txt: no such file or directory
1
<em>unix%</em> ls -l abc.txt def.txt <i>2&gt;&amp;1</i> | wc -l
2
</pre>
  <img src="images/fderr.png">
</section>

</section>

<!-- ############################## -->
<!-- ############################## -->
<!-- ############################## -->

<section id="pipes">

<section id="pipeintro">
  <h2>Anonymous pipes</h2>
  <img src="images/pipeintro.png">
  <br>
  <ul>
    <li>they are features provided by the operating system</li>
    <li>they're used by the shell when piping "<strong>command | command</strong>"</li>
    <li>a pipe is <strong>unidirectional</strong></li>
    <li>it connects a <em>writer</em> file descriptor of a process to a <em>reader</em> file descriptor of another process</li>
    <li>in between is a memory <strong>buffer</strong>, managed by the operating system</li>
    <li>the two processes have no real control over that buffer</li>
  </ul>
</section>

<!-- ****************************** -->

<section id="pipebufbehavior">
  <h2>Buffer behavior</h2>
  <img src="images/barrel.png">
  <br>
  The buffer's behavior can be compared to a barrel.
  <p>
  <ul>
    <li>process A, the <em>writer</em>, is pouring data in</li>
    <li>process B, the <em>reader</em>, is slurping data out</li>
  </ul>
  <p>
  Unlike a barrel of water, the data's I/O order is kept.
</section>

<!-- ****************************** -->

<section id="pipebufbehavior2">
  <h2>A filled buffer</h2>
  <img src="images/barrel_f.png">
  <br>
  When the <em>writer</em> produces data <strong>faster</strong><br>
  than the <em>reader</em> can process them:
  <p>
  <ul>
    <li>the buffer fills completely</li>
    <li>the operating system will <strong>suspend</strong> process A</li>
    <li>however, process B will run at full speed</li>
  </ul>
</section>

<!-- ****************************** -->

<section id="pipebufbehavior3">
  <h2>An empty buffer</h2>
  <img src="images/barrel_e.png">
  <br>
  When the <em>writer</em> produces data <strong>slower</strong><br>
  than the <em>reader</em> can process them:
  <p>
  <ul>
    <li>the buffer empties completely</li>
    <li>the operating system will <strong>suspend</strong> process B</li>
    <li>however, process A will run at full speed</li>
  </ul>
</section>

<!-- ****************************** -->

<section id="pipebufspecs">
  <h2>Buffer specs</h2>
  <ul>
    <li>in good old times, the buffer's size was <em>4096 bytes</em> (4 Kib)</li>
    <li>in most modern UNIX systems, it is now <em>65536 bytes</em> (64 Kib)</li>
    <li>blocking the reader or writer makes the system <strong>as efficient as possible</strong></li>
  </ul>
</section>

<!-- ****************************** -->

<section id="pipesetup">
  <h2>Setting up a pipe</h2>
  <img src="images/pipesetup.png">
  <br>
  If you look up the system calls of a UNIX system you'll<br>
  be surprised to discover that:
  <p>
  <ul>
    <li>given two existing processes A and B...</li>
    <li>... <i>there is no API</i> to create a pipe between them!</li>
  </ul>
</section>

<!-- ****************************** -->

<section id="pipesyscall">
  <h2>The pipe() system call</h2>
  <img src="images/pipesyscall.png">
  <p>
  There is however a system call that seems promising:
  <p>
  <ul>
    <li>it is called <em>pipe()</em></li>
    <li>it creates a buffer</li>
    <li>it connects to it two file descriptors of the process</li>
    <li>one for <em>reading</em>, one for <em>writing</em></li>
    <li>er... how is that useful ?!?</li>
    <li>... what can we do?</li>
  </ul>
</section>

<!-- ****************************** -->

<section id="pipefork">
  <h2>Pipe and fork...</h2>
  <img src="images/pipefork.png">
  <p>
  The solution is for the process to <em>fork()</em> after <em>pipe()</em>
  <p>
  <ul>
    <li>we get two processes</li>
    <li>both have access to both file descriptors</li>
    <li>the memory buffer is unique and shared</li>
  </ul>
</section>

<!-- ****************************** -->

<section id="pipeclose">
  <h2>Pipe, fork and close</h2>
  <img src="images/pipeclose.png">
  <p>
  Then, each process decides to <em>close()</em> one of their file descriptors.
  <p>
  To send data from parent to child:
  <p>
  <ul>
    <li>the parent closes the <em>read</em> descriptor</li>
    <li>the child closes the <em>write</em> descriptor</li>
  </ul>
</section>

<!-- ****************************** -->

<section id="pipeclose2">
  <h2>Pipe, fork and close 2</h2>
  <img src="images/pipeclose2.png">
  <p>
  To send data from child to parent:
  <p>
  <ul>
    <li>the parent closes the <em>write</em> descriptor</li>
    <li>the child closes the <em>read</em> descriptor</li>
  </ul>
</section>

<!-- ****************************** -->

<section id="pipeperl">
  <h2>An example in plain Perl</h2>
<pre class="transp"><code class="perl">#!/bin/perl

# Standard perl functions; no Perl libs, no strict, no nothin'
pipe(READFD,WRITEFD);

if (fork) { # this block is the parent process
  close(READFD);
  print WRITEFD "Good morning my son";
  print "I am parent process $$ and I exit now.\n";
  exit 0;
} else { # this block is the child process
  close(WRITEFD);
  $a=&lt;READFD&gt;;
  print "I am child process $$ and I read '$a' from my parent. Exiting now.\n";
  exit 0;
}
</code></pre>
<pre>
<em>unix%</em> perl pipe.pl
I am parent process 24891 and I exit now.
I am child process 24892 and I read 'Good morning my son' from my parent. Exiting now.
</pre>
</section>

<!-- ****************************** -->

<section id="popen">
  <h2>popen() to the rescue</h2>
  <ul>
    <li>these <em>pipe()</em>, <em>fork()</em>, and <em>close()</em> can be cumbersome</li>
    <li>yet piping to or from another process is a common need</li>
    <li>many languages have libraries with wrappers to do all that:</li>
  </ul>
  <p>
  <div class="cell">
    <ul>
      <li>C :<br><pre>fh=popen("ls -l","r");</pre></li>
      <li>Perl :<br><pre>open(FH,"ls -l|");
# or
my $fh = IO::File-&gt;new("ls -l|");     </pre></li>
</pre>
    </ul>
  </div>
  <div class="cell">
    <ul>
      <!-- I hate having to insert dummy trailing spaces in my code blocks! -->
      <li>PHP:<br><pre>$fh = popen("ls -l","r");</pre></li>
      <li>Ruby:<br><pre>fh = IO.popen("ls -l","r")             


</pre></li>
    </ul>
  </div>
</section>

<!-- ****************************** -->

<section id="pipetargz">
  <h2>Toolbox approach in action</h2>
  Some commands will use piping internally without telling you.
  <p>
  An example is <em>tar -c<strong>z</strong>f out.tar.gz somedir</em>
  <p>
  The tar command does <i>not</i> implement compression.<br>
  It delegates this to a <em>gzip</em> child process that it pipes to.
  <p>
  <img src="images/pipetargz.png">
</section>

<!-- ****************************** -->

<section id="pipetargz2">
<pre>
<em>unix%</em> tar -czf /tmp/dummy.tar.gz MainStore &amp;
[1] 28976
</pre>
<pre>
<em>unix%</em> pstree -p -a -c 28976
tar,28976 -czf /tmp/dummy.tar.gz MainStore
  |
  +--gzip,28977
</pre>
<pre>
<em>unix%</em> lsof -w -b -p 28976
COMMAND   PID  FD   TYPE  NAME
tar     28976   0u   CHR  /dev/pts/0
tar     28976   1u   CHR  /dev/pts/0
tar     28976   2u   CHR  /dev/pts/0
tar     28976   3r   REG  /data/MainStore/32/69/00/01221_2_t1.mnc.gz
tar     28976   4w  FIFO  pipe
</pre>
<pre>
<em>unix%</em> lsof -w -b -p 28977
COMMAND   PID  FD   TYPE  NAME
gzip    28977   0r  FIFO  pipe
gzip    28977   1w   REG  /tmp/dummy.tar.gz
gzip    28977   2u   CHR  /dev/pts/0
</pre>
</section>

</section>

<!-- ############################## -->
<!-- ############################## -->
<!-- ############################## -->

<section>

<section id="fifoprob">
  <h2>Named pipes (a.k.a. FIFOs)</h2>
  What if we wanted to establish a pipe<br>
  between two <strong>unrelated</strong> processes?
  <p>
  <ul>
    <li>the processes need to 'find' each other</li>
    <li>but PIDs aren't good enough</li>
    <li>process names and commands are not reliable</li>
    <li>we may want many such pipes</li>
    <li>so it would be nice if we could give them <strong>names</strong></li>
  </ul>
  <p>
  Instead of establishing a registry, or adding new system calls,<br>
  the UNIX designers chose the <strong>filesystem</strong> as a meeting place.
</section>

<!-- ****************************** -->

<section id="fifointro">
  <h2>Introducing FIFO files</h2>
  <small>(a.k.a. named pipes oh darn it)</small>
<pre>
<em>unix%</em> mkfifo abcde # on some system it's mknod
<em>unix%</em> ls -l abcde
prw-r--r--  1 prioux  staff  0 Jul 27 21:46 abcde
</pre>
  <ul>
    <li>this creates an entry in the filesystem (yes, an inode <i>is</i> used)</li>
    <li>this entry is permanent until deleted</li>
    <li>it is purely a place holder for communication</li>
    <li>no buffers or file descriptors are associated with it</li>
    <li>no space on the filesystem is used</li>
    <li>the size stays at <strong>0</strong></li>
    <li>normal file access restrictions apply</li>
  </ul>
</section>

<!-- ****************************** -->

<section id="fifobehave">
  <h2>How they are used</h2>
  Given a FIFO file, a process can, using <strong>standard file operations</strong>:
  <p>
  <ul>
    <li>write data to it</li>
    <li>read data from it</li>
  </ul>
  <p>
  Except, the data is <i>not</i> going to disk at all!
</section>

<!-- ****************************** -->

<section id="fifobehave2">
  <h2>How two processes communicate with FIFOs</h2>
  Processes can independantly start reading from,<br>
  or writing to, the FIFO file.
  <p>
  <img src="images/fifothink.png">
</section>

<!-- ****************************** -->

<section id="fifobehave3">
  <h2>But the OS takes over!</h2>
  However, the data requests are intercepted <small>(kind of)</small>
  and they instead go to a memory buffer just like for anonymous pipes.
  <p>
  <img src="images/fiforeal.png">
</section>

<!-- ****************************** -->

<section id="fifoprops">
  <h2>Other properties of FIFOs</h2>
  <ul>
    <li>a process can start reading or writing even if the other process does not yet exist</li>
    <li>in that case, the first process will block</li>
    <li>FIFOs can be reused</li>
    <li>you can delete the FIFO file while in use (!)</li>
    <li>FIFO files can only be created on some filesystem types</li>
  </ul>
</section>

<!-- ****************************** -->

<section id="fifoex">
  <h2>An example in BASH</h2>
Preparation:
  <p>
  <div>
<pre>
<em>unix%</em> mkfifo robot.pdf    # this file is neither a robot nor a PDF!
<em>unix%</em> ls -l robot.pdf
prw-r--r--  1 prioux  staff  0 Jul 28 10:52 robot.pdf|           
</pre>
  </div>

  <p>
  In two separate shells, side by side:
  <p>

  <div class="cell">
<pre>
<em>unix%</em> echo "Ceci n'est pas une pipe" &gt; robot.pdf           
</pre>
  </div>
  <div class="cell">
<pre>
<em>unix%</em> cat &lt; robot.pdf           
Ceci n'est pas une pipe
</pre>
  </div>
</section>

<!-- ****************************** -->

<section id="pipecomp">
  <h2>A mistake I made</h2>
  FIFOs only allow processes running on the <i>same</i><br>
  computer to exchange data.
  <p>
  <img src="images/pipecomp.png">
</section>

</section>

<!-- ############################## -->
<!-- ############################## -->
<!-- ############################## -->

<section id="sockets">

<section id="sockets1">
  <h2>Sockets</h2>
  <ul>
    <li>they can connect two processes on the <em>same</em> computer</li>
    <li>they can connect two processes on <em>different</em> computers</li>
  </ul>
  <img src="images/sockets1.png">
  <br>
  Note: this is the <strong>only</strong> IPC mechanism that can connect processes on different computers!
</section>

<!-- ****************************** -->

<section id="sockprops">
  <h2>Socket properties</h2>
  <ul>
    <li>just like pipes, the processes use file descriptors</li>
    <li>they are <em>bidirectional</em></li>
    <li>... each process reads and writes to one file descriptor</li>
    <li>the streams of bytes are <em>buffered</em> by the operating systems</li>
    <li>... which can lead to <em>blocking</em></li>
    <li>care must be taken not to enter a <strong>deadlock</strong></li>
    <li>fortunately the OS provides calls to check if data is available or not without blocking</li>
  </ul>
</section>

<!-- ****************************** -->

<section id="socktypes1">
  <h2>Network sockets vs UNIX-domain sockets</h2>
  These two types of IPC end up providing the same feature,<br>
  that is a bidirectional data flow.
  <p>
  They differ in how the data is <em>transported</em><br>
  and how the processes find themselves.
</section>

<!-- ****************************** -->

<section id="socktypes2">
  <h2>For network sockets</h2>
  <ul>
    <li>the stream is sent in packets over the network (duh)</li>
    <li>the processes find each other by interfaces, IP addresses, port numbers, etc</li>
    <li>the processes <strong>can be</strong> on two <em>different</em> computers</li>
  </ul>
  <img src="images/sock_net.png">
</section>

<!-- ****************************** -->

<section id="socktypes3">
  <h2>For UNIX-domain sockets</h2>
  <ul>
    <li>the stream is sent in memory buffers within the OS</li>
    <li>the processes find each other with a <em>socketfile</em></li>
    <li>the <em>socketfile</em> is a placeholder just like for named pipes</li>
    <li>the processes <strong>have to be</strong> on the <em>same</em> computer.</li>
  </ul>
  <img src="images/sock_unix.png">
</section>

<!-- ****************************** -->

<section id="socketpres1">
  <h2>Summarizing another presentation</h2>
  I already presented computer networking in<br>
  details back in 2013, including network sockets.
  <p>
  That presentation is available in the <strong>Documents</strong><br>
  tab of the ACELab <strong>Redmine</strong> tracker, in project <em>ACELab IT</em>.
  <p>
  <img src="images/redm_1.png" style="width: 50%">
  <br>
  <img src="images/redm_2.png" style="width: 50%">
</section>

<!-- ****************************** -->

<section id="socketpres2">
  <h2>In that presentation...</h2>
  <div class="cell">
    <ul>
      <li>interfaces</li>
      <li>IP addresses</li>
      <li>port numbers</li>
      <li>packets</li>
      <li>etc...</li>
    <ul>
  </div>
  <div class="cell">
    <img src="images/sock_pres1.png" style="width: 50%">
  </div>
</section>

<!-- ****************************** -->

<section id="socketfind">
  <h2>How processes find each other</h2>
  Here's a quick summary of how a connection is<br>
  set up. This applies to both types of sockets.
  <p>
  <ul>
    <li>one process establish itself as a <em>listener</em><br>
       <small>Network: <em>(IP, port)</em> vs UNIX: <em>(socketfile)</em></small>
    </li>
    <li>another process connects to it by specifying the same parameters</li>
    <li>the listener accepts the connection</li>
    <li>the operating system(s) transport the stream of bytes</li>
    <li>the two processes <em>read</em> and <em>write</em> to their file descriptors</li>
  </ul>
</section>

<!-- ****************************** -->

<section id="sockmulti">
  <h2>Many-to-one connections</h2>
  Sockets are the only IPC mechanism that allow many processes
  to communicate with the <em>listener</em> process.
  <p>
  <img src="images/sockmulti.png">
</section>

<!-- ****************************** -->

<section id="sockaccess">
  <h2>Access control</h2>
  There is <i>no</i> particular access control for this type of IPC<br>
  based on the <strong>owner</strong> or <strong>groups</strong> of the processes involved.
  <p>
  <ul>
    <li>UNIX-domain sockets: the <em>socketfile</em>'s permissions apply</li>
    <li>network sockets: the external network routing, firewall etc</li>
    <li>the listener process can reject connections based on source...</li>
    <li>... or (most often) on content exchanged (protocol violations)</li>
  </ul>
</section>

</section>

<!-- ############################## -->
<!-- ############################## -->
<!-- ############################## -->

<section id="overview">

<section id="overviewtable">
  <h2>IPC mechanisms overview</h2>
  <table class="smallcontent">

    <tr>
      <th><br>IPC</th>
      <th><br>Bidirectional?</th>
      <th>Multi computer?</th>
      <th>Process relationships</th>
    </tr>

    <tr>
      <td>Signals</td>
      <td><i>no</i></td>
      <td><i>no</i></td>
      <td>any (same owner)</td>
    </tr>

    <tr>
      <td>Environment variables</td>
      <td><i>no</i></td>
      <td><i>no</i></td>
      <td>forked children only</td>
    </tr>

    <tr>
      <td>Pipes</td>
      <td><i>no</i></td>
      <td><i>no</i></td>
      <td>forked children only</td>
    </tr>

    <tr>
      <td>Named Pipes</td>
      <td><i>no</i></td>
      <td><i>no</i></td>
      <td>any, but <em>fifo file</em> permissions apply</td>
    </tr>

    <tr>
      <td>Network sockets</td>
      <td><em>yes</em></td>
      <td><em>yes</em></td>
      <td>any, but firewalls etc apply</td>
    </tr>

    <tr>
      <td>UNIX-domain sockets</td>
      <td><em>yes</em></td>
      <td><i>no</i></td>
      <td>any, but <em>socketfile</em> permissions apply</td>
    </tr>

  </table>
</section>

</section>

<!-- ############################## -->
<!-- ############################## -->
<!-- ############################## -->

<section id="quiz">

<section id="quiz1">
  <h2>A quiz</h2>
  This is based on a true story, here at the lab.
  <p>
  <em>Setting</em>: We had a UNIX machine with small disk space. Largest<br>
  partition: 80G dedicated to the LORIS development MySQL DBs.
  <p>
  <ul>
    <li>the disk is nearly full.</li>
    <li>we identified a BIGDB inside the MySQL server using about 5G</li>
    <li>we think it's filled with obsolete 'temp' data</li>
    <li>we want to delete the DB <strong>after making a backup of the data</strong></li>
  <ul>
  <br>
  We <i>cannot</i> do this, we don't have the disk space for <em>file.sql</em>:
  <pre><em>unix%</em> mysqldump [options] BIGDB &gt; file.sql</pre>
</section>

<!-- ****************************** -->

<section id="quiz2">
  <h2>Quiz: the command</h2>
  Instead I ran this:
  <br>
  <pre><em>unix%</em> mysqldump [options] BIGDB | gzip -c | ssh me@remote.host 'cat &gt; dump.sql.gz'</pre>
  <br>
  Using what you all collectively know about UNIX:
  <p>
  <ol>
    <li>how many processes are involved?</li>
    <li>which processes are they?</li>
    <li>which IPC mechanisms are used?</li>
  </ol>
</section>

<!-- ****************************** -->

<section id="quiz3">
  <h2>Quiz: the diagrams</h2>
  <pre><em>unix%</em> mysqldump [options] BIGDB | gzip -c | ssh me@remote.host 'cat &gt; dump.sql.gz'</pre>

  Let's identify the processes.

  <p class="fragment">
  The easy ones: the processes we see on the command line:

  <p class="fragment">
  <img src="images/quiz_proc1.png">

  <p class="fragment">
  They run on two different computers, right?

  <p class="fragment">
  <img src="images/quiz_proc2.png">
</section>

<!-- ****************************** -->

<section id="quiz4">
  <pre><em>unix%</em> mysqldump [options] BIGDB | gzip -c | ssh me@remote.host 'cat &gt; dump.sql.gz'</pre>
  <p>
  They were are all started by some other processes, right?<br>
  And what about the DB server process itself?
  <p class="fragment">
  <img src="images/quiz_proc3.png">
  <small>Note: two <em>sshd</em> processes are in fact involved...</small>
</section>

<!-- ****************************** -->

<section id="quiz5">
  <pre><em>unix%</em> mysqldump [options] BIGDB | gzip -c | ssh me@remote.host 'cat &gt; dump.sql.gz'</pre>
  <p>
  Now let's draw the connections to files.<br>
  These are standard file operations, not IPC.
  <p class="fragment">
  <img src="images/quiz_proc_fs.png">
</section>

<!-- ****************************** -->

<section id="quiz6">
  <pre><em>unix%</em> mysqldump [options] BIGDB | gzip -c | ssh me@remote.host 'cat &gt; dump.sql.gz'</pre>
  <img src="images/quiz_proc_fs.png">
  OK now, what are <em>all the IPC mechanisms</em><br>
  operating between these processes?
  <p>
  Recap: <span style="color: #8f0">Signals</span>,
         <span style="color: #0f8">Environment Variables</span>,
         <span style="color: #f0f">Anonymous Pipes</span>,
         <span style="color: #0ff">Named Pipes</span>,
         <span style="color: #f80">Network Sockets</span>,
         <span style="color: #f00">UNIX-Domain Sockets</span>
</section>

<!-- ****************************** -->

<section id="quizannot">
  <pre><em>unix%</em> mysqldump [options] BIGDB | gzip -c | ssh me@remote.host 'cat &gt; dump.sql.gz'</pre>
  <img src="images/quiz_annot.png">
</section>

</section>

<!-- ############################## -->
<!-- ############################## -->
<!-- ############################## -->

<section id="end">

<section id="final">
  <h2>Thank you</h2>
  I'm hoping this overview of IPC has help you all<br>
  in understanding better how the <strong>applications we write</strong>,<br>
  and the <strong>commands we run</strong>, interact <em>with each other</em><br>
  and <em>with the system</em>.
  <p class="fragment">
  Presented in four parts: June 2016 - October 2016
  <p class="fragment">
  I'm willing to present again any previous parts of this<br>
  presentation, for those who have missed them.
  <br><br>
  <small>
  (This offer includes the <strong>GIT</strong>,
  the <strong>File system</strong>, and the <strong>Networking</strong> presentations too)
  </small>
</section>

</section>

<!-- ############################## -->
<!-- ############################## -->
<!-- ############################## -->

    </div>
  </div>

  <!-- Main reveal.js setup -->

  <script src="lib/js/head.min.js"></script>
  <script src="js/reveal.js"></script>
  <script src="plugin/highlight/highlight.js"></script>
  <script>
    Reveal.initialize(
    { slideNumber: true, history: true }
    );
    hljs.initHighlightingOnLoad();
  </script>

  <!-- Styles -->

  <style>

    /* Headers */

    .reveal h1,
    .reveal h2,
    .reveal h3,
    .reveal h4,
    .reveal h5 {
      color: #ffffff;
      text-shadow: 0.0em 0.0em 0.2em #0cc;
    }

    /* Text styles: em, strong, b, i */

    .reveal em {
      color: yellow;
      font-style: normal; /* yes please! */
    }
    .reveal strong {
      color: #0ff;  /* funny, I'm using RGB with only three digits today */
    }
    .reveal b {
      color: #00f;
    }
    .reveal i {
      color: #f00;
    }

    /* Misc */

    .reveal section img {
      background: transparent;
      border: none;
      box-shadow: none;
    }
    .reveal pre {
      background: #033;
      padding: 0.2em 0.5em 0.3em 0.5em;
    }
    .reveal .cell {
      display: table-cell;
    }
    .reveal th {
      color: #0aa;
    }
    .reveal .transp {
      background-color: transparent;
    }

    .reveal .smallcontent tr td {
      font-size: 70%;
    }

  </style>
</body>

</html>
